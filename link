#!/bin/bash

set -u

force=0

link () {
    # Link a file to a destination using a relative path
    path="$(abspath "$path")"

    if [ $# -gt 1 ]; then
        link_path="$(abspath "$2")"
    else
        link_path="$HOME/$path"
    fi
    destdir="${link_path%/*}"
    if [ "$destdir" != "$link_path" ]; then
        mkdir -p "$destdir"
    fi
    relative_path="$(relpath "$destdir" "$path")"

    # Sanity check
    link_resolved="$(normalize_path "${link_path%/*}/$relative_path")"
    if [ ! -e "$link_resolved" ]; then
        echo >&2 "Error: $link_resolved does not exist"
        return 1
    fi

    if [ -L "$link_path" ] || [ -e "$link_path" ]; then
        if [ $force -eq 0 ] && [ "$(readlink "$link_path")" != "$relative_path" ]; then
            echo >&2 "Warning: $link_path already exists and does not link to $relative_path"
            if prompt_bool "Replace $link_path?"; then
                rm -rf "$link_path.old"
                mv "$link_path" "$link_path.old"
                echo >&2 "Removed $link_path (backed up as $link_path.old)"
            else
                rm -rf "$link_path.new"
                ln -s "$relative_path" "$link_path.new"
                echo >&2 "Linked $link_path.new"
                return 1
            fi
        else
            rm -f "$link_path"
        fi
    fi
    ln -s "$relative_path" "$link_path"
    echo >&2 "Linked $link_path"
}

abspath () {
    # Return an absolute path for the specified argument
    _path="$1"
    if [ -n "${_path##/*}" ]; then
        _path="$PWD/$1"
    fi
    echo "$_path"
}

normalize_path () {
    # Attempt to normalize the specified path, removing . and ..

    # Remove all /./ sequences.
    local path="${1//\/.\//\/}"

    # Remove dir/.. sequences.
    while [[ $path =~ ([^/][^/]*/\.\./) ]]; do
        path="${path/${BASH_REMATCH[0]}/}"
    done
    echo "$path"
}

prompt_bool () {
    if [[ $# -gt 1 ]]; then
        default="$2"
    else
        default="y"
    fi
    case $default in
        [yY])
            y_side="Y"
            n_side="n"
            default_code=0
            ;;
        [nN])
            n_side="N"
            y_side="y"
            default_code=1
            ;;
    esac

    while true; do
        read -n 1 -p "$1 [$y_side|$n_side] " result </dev/tty
        printf "\n"
        case "$result" in
            [yY])
                return 0
                ;;
            [nN])
                return 1
                ;;
            "")
                return $default_code
                ;;
            *)
                echo >&2 "Invalid input '$result'"
                ;;
        esac
    done
}

home_link () {
    path="$1"
    link_path="$2"

    if [[ ! -d "$path" ]]; then
        if [[ -d "$link_path" ]]; then
            if prompt_bool "$link_path exists and is a directory, move to $path?"; then
                mkdir -p "${path%/*}"
                mv "$link_path" "$path"
            fi
        elif [[ -d "Dropbox/$link_path" ]]; then
            if prompt_bool "Dropbox/$link_path exists and is a directory, move to $path?"; then
                mkdir -p "${path%/*}"
                mv "Dropbox/$link_path" "$path"
            fi
        else
            echo >&2 "Error: source $link_path does not exist, skipping"
            return 1
        fi
    fi

    mkdir -p "${link_path%/*}"
    link "$path" "$link_path"
}


scriptdir="$(cd "${0%/*}" && pwd)"
cd

while IFS="	" read filename path_pattern link_path_pattern; do
    if [ ! -e "$filename" ]; then
        continue
    fi

    grep -v "^#" "$filename" | while IFS="	" read rel_path rel_link_path; do
        if [[ -z "$rel_path" ]]; then
            continue
        fi

        if [[ -z "$rel_link_path" ]]; then
            rel_link_path="$rel_path"
        fi

        path="$(printf "$path_pattern" "$rel_path")"
        link_path="$(printf "$link_path_pattern" "$rel_link_path")"

        home_link "$path" "$link_path"
    done
done <<END
$scriptdir/Links.txt	%s	%s
$scriptdir/DropboxLinks.txt	Dropbox/%s	%s
$scriptdir/DropboxGames.txt	Dropbox/Games/%s	Documents/%s
$scriptdir/DropboxApps.txt	Dropbox/Apps/%s	Documents/%s
END
